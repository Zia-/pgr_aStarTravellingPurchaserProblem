-- THE FOLLOWING PROCEDURAL FUNCTION WILL SOLVE OUR TRAVELLING PURCHASER PROBLEM --
-- Install "pgr_aStarFromAtoB" (https://github.com/Zia-/pgr_aStarFromAtoBviaC) function beforehand --
-- The arguments are the table name, the starting and ending points coord and the via points ids (which we have defined in
-- the individual_stops table - Consult the Documentation) --
-- DROP FUNCTION test(character varying,double precision,double precision,double precision,double precision,double precision[])

create or replace function pgr_aStarTPP_stdistance_farthest(IN tbl character varying, 
IN x1 double precision,
IN y1 double precision,
IN x2 double precision,
IN y2 double precision,
variadic double precision[],
OUT seq integer, 
OUT gid integer, 
OUT name text,
OUT cost double precision,
OUT geom geometry
)
RETURNS SETOF record AS
$body$
declare
	breakwhile integer;
	ending_id integer;
	via_id integer;
	sql_tsp text;
	source_var integer;
	rec_tsp record;
	node record;
	target_var integer;	
	sql_astar text;
	rec_astar record;
	sum_cost double precision;
	sum_cost_again double precision;
	sum_cost_rec record;
	sql_loop text;
	sql_loop1 text;
	sql_loop2 text;
	sql_loop3 text;
	rec_loop1 record;
	rec_loop2 record;
	rec_loop3 record;
begin
	create temporary table route (geom_route geometry);
	insert into route select st_union(pgr.geom) as geom_route from pgr_astarfromatob('ways', x1, y1, x2, y2) as pgr;
	breakwhile := array_length($6,1);
	create temporary table matrix (id integer, node_id integer, x double precision, y double precision);
	ending_id = breakwhile + 2;
	execute 'insert into matrix (id, node_id, x, y) select 1, id, st_x(the_geom)::double precision, st_y(the_geom)::double precision from ways_vertices_pgr 
		ORDER BY the_geom <-> ST_GeometryFromText(''Point('||x1||' '||y1||')'', 4326) limit 1';
	execute 'insert into matrix (id, node_id, x, y) select '||ending_id||', id, st_x(the_geom)::double precision, st_y(the_geom)::double precision from ways_vertices_pgr 
		ORDER BY the_geom <-> ST_GeometryFromText(''Point('||x2||' '||y2||')'', 4326) limit 1';
	For i in 1..breakwhile Loop
		via_id := i + 1;
		execute  'with distance as (
			select st_makepoint(x, y) as geom_distance from individual_stops, route where id = '||$6[i]||' order by st_distance(geom_route, the_geom) limit 1 
			)
			insert into matrix (id, node_id, x, y) select '||via_id||', id, st_x(the_geom)::double precision, st_y(the_geom)::double precision
			from ways_vertices_pgr, distance ORDER BY the_geom <-> st_setsrid(geom_distance, 4326) limit 1;'; 
	end loop;
	sql_tsp := 'select seq, id1, id2, round(cost::numeric, 5) AS cost from
			pgr_tsp(''select id, x, y from matrix order by id'', 1, '||ending_id||')'; 
	seq := 0;
	source_var := -1;
	sum_cost := 0;
	FOR rec_tsp IN EXECUTE sql_tsp
		LOOP
			If (source_var = -1) Then
				execute 'select node_id from matrix where id = '||rec_tsp.id2||'' into node;
				source_var := node.node_id;
			Else
				execute 'select node_id from matrix where id = '||rec_tsp.id2||'' into node;
				target_var := node.node_id;
				execute 'SELECT sum(cost) as summation
						FROM ' ||
						'pgr_astar(''SELECT gid as id, source::integer, target::integer, '
						|| 'length::double precision AS cost, '
						|| 'x1::double precision, y1::double precision,'
						|| 'x2::double precision, y2::double precision,'
						|| 'reverse_cost::double precision FROM '
						|| quote_ident(tbl) || ''', '
						|| source_var || ', ' || target_var 
						|| ' , true, true), '
						|| quote_ident(tbl) || ' WHERE id2 = gid ORDER BY seq' into sum_cost_rec;
				sum_cost := sum_cost + sum_cost_rec.summation;
			END IF;
		END LOOP;
	sum_cost := sum_cost * 1000;
	create temporary table loop (geom_loop geometry, id integer);
	For i in 1..breakwhile Loop
		execute  'insert into loop (geom_loop, id) select the_geom, id from individual_stops, route where 
				id = '||$6[i]||' and 
				st_distance(st_transform(st_geomfromtext(''Point('||x1||' '||y1||')'', 4326),32635),st_transform(the_geom),32635)+st_distance(st_transform(st_geomfromtext(''Point('||x2||' '||y2||')'', 4326),32635),st_transform(the_geom),32635) < '||sum_cost||'
				order by st_distance(geom_route, the_geom)'; 
	end loop;
	sql_loop1 := 'select * from loop where id = '||$6[1]||'';
	FOR rec_loop1 IN EXECUTE sql_loop1 
		Loop
			sql_loop2 := 'select * from loop where id = '||$6[2]||'';
			FOR rec_loop2 IN EXECUTE sql_loop2
				Loop
					sql_loop3 := 'select * from loop where id = '||$6[3]||'';
					FOR rec_loop3 IN EXECUTE sql_loop3
						Loop
							create temporary table matrix_sub (id integer, node_id integer, x double precision, y double precision);
							execute 'insert into matrix_sub (id, node_id, x, y) select 1, id, st_x(the_geom)::double precision, st_y(the_geom)::double precision from 										ways_vertices_pgr ORDER BY the_geom <-> ST_GeometryFromText(''Point('||x1||' '||y1||')'', 4326) limit 1';
							execute 'insert into matrix_sub (id, node_id, x, y) select '||ending_id||', id, st_x(the_geom)::double precision, st_y(the_geom)::double precision from 										ways_vertices_pgr ORDER BY the_geom <-> ST_GeometryFromText(''Point('||x2||' '||y2||')'', 4326) limit 1';
							execute 'insert into matrix_sub (id, node_id, x, y) select 2, id, st_x(the_geom)::double precision, st_y(the_geom)::double precision
									from ways_vertices_pgr ORDER BY the_geom <-> st_setsrid('||rec_loop1.the_geom||', 4326) limit 1;';
							execute 'insert into matrix_sub (id, node_id, x, y) select 3, id, st_x(the_geom)::double precision, st_y(the_geom)::double precision
									from ways_vertices_pgr ORDER BY the_geom <-> st_setsrid('||rec_loop2.the_geom||', 4326) limit 1;';
							execute 'insert into matrix_sub (id, node_id, x, y) select 4, id, st_x(the_geom)::double precision, st_y(the_geom)::double precision
									from ways_vertices_pgr ORDER BY the_geom <-> st_setsrid('||rec_loop3.the_geom||', 4326) limit 1;';
							sql_tsp := 'select seq, id1, id2, round(cost::numeric, 5) AS cost from pgr_tsp(''select id, x, y from matrix_sub order by id'', 1, '||ending_id||')'; 
							seq := 0;
							source_var := -1;
							sum_cost_again := 0;		
							FOR rec_tsp IN EXECUTE sql_tsp
								LOOP
									If (source_var = -1) Then
										execute 'select node_id from matrix_sub where id = '||rec_tsp.id2||'' into node;
										source_var := node.node_id;
									Else
										execute 'select node_id from matrix_sub where id = '||rec_tsp.id2||'' into node;
										target_var := node.node_id;
										execute 'SELECT sum(cost) as summation
												FROM ' ||
												'pgr_astar(''SELECT gid as id, source::integer, target::integer, '
												|| 'length::double precision AS cost, '
												|| 'x1::double precision, y1::double precision,'
												|| 'x2::double precision, y2::double precision,'
												|| 'reverse_cost::double precision FROM '
												|| quote_ident(tbl) || ''', '
												|| source_var || ', ' || target_var 
												|| ' , true, true), '
												|| quote_ident(tbl) || ' WHERE id2 = gid ORDER BY seq' into sum_cost_rec;
										sum_cost_again := sum_cost_again + sum_cost_rec.summation;
									END IF;
								END LOOP;
							sum_cost_again := sum_cost_again * 1000;
							If (sum_cost_again < sum_cost) Then
								drop table matrix;
								create temporary table matrix (id integer, node_id integer, x double precision, y double precision);
								insert into matrix (id, node_id, x, y) select id, node_id, x, y from matrix_sub;
								
							Else
							END IF;
							drop table matrix_sub;
						END Loop;
				End Loop;
		End Loop;
	sql_tsp := 'select seq, id1, id2, round(cost::numeric, 5) AS cost from	pgr_tsp(''select id, x, y from matrix order by id'', 1, '||ending_id||')'; 
	seq := 0;
	source_var := -1;
	FOR rec_tsp IN EXECUTE sql_tsp
		LOOP
			If (source_var = -1) Then
				execute 'select node_id from matrix where id = '||rec_tsp.id2||'' into node;
				source_var := node.node_id;
			Else
				execute 'select node_id from matrix where id = '||rec_tsp.id2||'' into node;
				target_var := node.node_id;
				-- Here we will calculate the shortest route between all the pairs of nodes using aStar(), which must be travlled in the order --
				sql_astar := 'SELECT gid, the_geom, name, cost, source, target, 
						ST_Reverse(the_geom) AS flip_geom FROM ' ||
						'pgr_astar(''SELECT gid as id, source::integer, target::integer, '
						|| 'length::double precision AS cost, '
						|| 'x1::double precision, y1::double precision,'
						|| 'x2::double precision, y2::double precision,'
						|| 'reverse_cost::double precision FROM '
						|| quote_ident(tbl) || ''', '
						|| source_var || ', ' || target_var 
						|| ' , true, true), '
						|| quote_ident(tbl) || ' WHERE id2 = gid ORDER BY seq';
				-- Extracting the geom obtained from each pair aStar() in a row by row manner and returning it back to the pgr_aStarTPP_stdistance_closest() --
				For rec_astar in execute sql_astar
					Loop
						seq := seq +1 ;
						gid := rec_astar.gid;
						name := rec_astar.name;
						cost := rec_astar.cost;
						geom := rec_astar.the_geom;
						RETURN NEXT;
					End Loop;
				source_var := target_var;
				RETURN NEXT;
			END IF;
		END LOOP;	
	-- Drop the temporary tables, otherwise the next time you will run the query it will show that the matrix table or route table already exists --
	drop table route;
	drop table matrix;
	drop table loop;
	return;
end;
$body$
language plpgsql volatile STRICT;












